# Firecracker snapshot versioning

This document describes how Firecracker persists its state across multiple versions, diving deep into the snapshot format, encoding, compatibility and limitations. 

## Introduction
The design behind the snapshot implementation enables version tolerant save and restore across multiple Firecracker versions which we call a version space. For example, one can pause a microVM, save it to disk with Firecracker version **0.26.0** and later load it in Firecracker version **0.24.0**. It also works  in reverse: Firecracker version **0.26.0** loads what  **0.24.0** saves. 

Below is an example graph showing backward and forward snapshot compatibility for a version space formally represented as `[v2; vn]`. This is the general picture, but keep in mind that future corner cases might remove edges from this graph.

![Version graph](
../images/version_graph.png?raw=true
"Version graph")

## Overview
Firecracker persists the microVM state as 2 separate objects:
 - a **guest memory** file
 - a **microVM state** file.
 
*The block devices attached to the microVM are not considered part of the state and need to be managed separately.*

### Guest memory
The guest memory file is agnostic to Firecracker's version tolerant save/restore implementation as its contents are fully owned by the guest OS. The microVM memory is by choice saved as a dump of each page or as a sparse file of guest modified pages only. 
### MicroVM state
The microVM state file stores the internal state of the VMM (device emulation, KVM and vCPUs) with 2 exceptions - serial emulation and vsock backend. 

While we continuously improve and extend Firecracker's features by adding new capabilities, devices or enhancements, the microVM state file may change both structurally and semantically with each new release. The state file includes versioning information and each Firecracker release implements distinct save/load logic for the supported version space. 

## MicroVM state file format

###  A closer look
A microVM state file is further split into four different fields:

| Field | Bits| Description |
|----|----|----|
| magic_id | 64 | Firecracker snapshot, architecture (x86_64/aarch64) and storage version.
| version  | 16 | The snapshot version number internally mapped 1:1 to a specific Firecracker version.
| state | N | Bincode blob containing the microVM state.
 | crc| 64 | Optional CRC64 sum of magic_id, version and state fields.

Note: the last 16 bits of `magic_id` encode the storage version which specifies the encoding used for the `version` and `state` fields. The current implementation sets this field to 1, which identifies it as a [Serde bincode](https://github.com/servo/bincode) compatible encoder/decoder.

### Version tolerant ser/de
Firecracker reads and writes the `state` blob of the snapshot by using per version, separate serialization and deserialization logic. This logic is mostly autogenerated by a Rust procedural macro based on `struct`, `enum` and `union` annotations. Basically, one can say that these structures support versioning. The versioning logic is generated by parsing a structure's history log (encoded using Rust annotations) and emitting Rust code.

Versioned serialization and deserialization is divided into two translation layers:
 - structural translator,
 - semantic translator.

The _structural translator_ implements the logic to convert between different versions of the same Rust POD structure: it can deserialize or serialize from source version to target. 
The translation is done field by field - the common fields are copied from source to target, and the fields that are unique to the target are (de)serialized with their default values.

The _semantic translator_ works on top of the structural one and its only concern is translating the semantics of the serialized/deserialized fields. 

The _structural translator_ is generated automatically through a procedural macro, and the _semantic translation methods_ have to be annotated in the structure by the user.

This block diagram illustrates the concept:

![Versionize](
../images/versionize.png?raw=true
"Versionize layers")

## Bincode encoding
During research and prototyping we have considered multiple storage formats. The criteria used for comparing these were performance, size, Rust support, specification, versioning support, community popularity and tooling. Performance, size and Rust support are hard requirements while all others can be the subject of trade-offs. 

More info about this comparison can be found [here](https://github.com/firecracker-microvm/firecracker/blob/9d427b33d989c3225d874210f6c2849465941dc0/docs/snapshotting/design.md#we-also-looked-at-these-other-options).

Key benefits of using `bincode` versus everything else are:
- Minimal snapshot size overhead,
- Minimal CPU overhead,
- Simple implementation.

## Snapshot compatibility
### Host kernel

The minimum kernel version required by Firecracker snapshots is 4.14. Snapshots can be saved and restored on different kernel versions without issues.

### Device model
The microVM state file links some resources that are external to the snapshot:
- tap devices by device name,
- block devices by block file path,
- vsock backing Unix domain socket by socket name.

To successfully restore a microVM one should check that:
- tap devices are available, their names match their original names since these are the values saved in the microVM state file, and they are accessible to the Firecracker process where the microVM is being restored,
- block devices are set up at their original relative or absolute paths with the proper permissions, as the Firecracker process with the restored microVM will attempt to access them exactly as they were accessed in the original Firecracker process,
- the vsock backing Unix domain socket is available, its name matches the original name, and it is accessible to the
new Firecracker process.

### CPU model

Firecracker microVMs can run on any Intel x86_64 CPU models that support the hardware virtualizations extensions. Snapshots, however, are not compatible across all Intel x86_64 CPU models. They are only compatible if the CPU features exposed to the guest are an invariant when saving and restoring the snapshot.
The trivial scenario is creating and restoring snapshots on hosts that have the same CPU model. 
To relax this limitation, Firecracker provides an API to select a CPU template. Firecracker CPU templates work by using CPUID masking that restricts the exposed features to a common denominator of multiple CPU models.


## Implementation

To enable cross version snapshot save/load we have designed and built two crates:
- [versionize](https://crates.io/crates/versionize) - defines the Versionize trait, implements serialization of primitive types and provides a helper class to map Firecracker versions to individual structure versions.
- [versionize_derive](https://crates.io/crates/versionize_derive) - exports a procedural macro that consumes structures, enums or unions and their annotations to produce an implementation of the `Versionize` trait

The microVM state file format is implemented in the [snapshot crate](../../src/snapshot/src/lib.rs) in the Firecracker repository. 
All Firecracker devices implement the [Persist](../../src/snapshot/src/persist.rs) trait which exposes an interface that enables creating from and saving to the microVM state.